from django.shortcuts import render
from django.http import StreamingHttpResponse, HttpResponse
from django.core.paginator import Paginator


from library.models import compound
import pylab
import cStringIO

import statistics.plot_statistics as stat

#=============================================================================
## facilitate functions
def fig_out(format_out ='png'):
    """ Write the output figure generated by pylab into a string that can be used in html\n
    Default output format is PNG. \n
    SVG format doesn't work yet. This function will be updated for svg output in the future    
    """
    sio = cStringIO.StringIO()
    pylab.savefig(sio, format=format_out)
    image_string = """<img src="data:image/png;base64,%s"/><br>""" % sio.getvalue().encode("base64").strip()
    return image_string
    


def index(request):
    return render(request, "statistics/index.html")

def plot(request):
    """Plot data dynamically on the page
    This is a test page for ther
    """
    query1 = compound.objects.all().filter(plate = '3265')
    y1 = []
    for q in query1:
        y1.append(q.molecular_weight)        
    pylab.title('Scatter_plot')
    pylab.xlabel('test_xlabel')
    pylab.ylabel('test_ylabel')    
    pylab.plot(y1, 'ro', label='group1')

    c = fig_out()    
    
    return HttpResponse(c)

def compound_list(request):
    """ display list of compounds \n
    This function is supposed to be used by users to select a few compounds \n
    And it will return this table as summary    
    """
    entry_list = compound.objects.filter(plate = '3266')
    field_list = []
    for i in compound._meta.fields:
        if i.name not in 'pubchem_cid id fp2 fp3 fp4 sdf plate well canonical_smiles inchi molecular_weight formula':            
            field_list.append((i.name))
    
    current_page = (request.GET.get('page'))
        
    p = Paginator(entry_list,30)    
    
    if not current_page:
        current_page=1   
   
    if p.num_pages <=7:
        page_range = range(1,(p.num_pages+1))        
    elif int(current_page)+3 >= p.num_pages:
        page_range = range(p.num_pages - 7, p.num_pages)
    else:
        page_range = range(max(1,int(current_page)-3),max(1,int(current_page)-3)+7) 
        

    return render(request, "statistics/compounds.html",{'entry_list': p.page(current_page),
                                                  'field_list': field_list,
                                                  'pages': page_range,
                                                  'last_page':p.num_pages
                                                })    
     
def details(request):
    """ display detailed information of compounds, use list"""
    entry_list = compound.objects.filter(plate = '3266')#.filter(well = 'A05')
    field_list = []
    for i in compound._meta.fields:
        if i.name not in 'id fp2 fp3 fp4 sdf':            
            field_list.append((i.name))
                        
    current_page = (request.GET.get('page'))
        
    p = Paginator(entry_list,per_page = 1)    
    
    if not current_page:
        current_page=1
    
    if p.num_pages <=7:
        page_range = range(1,(p.num_pages+1))        
    elif int(current_page)+3 >= p.num_pages:
        page_range = range(p.num_pages - 7, p.num_pages)
    else:
        page_range = range(max(1,int(current_page)-3),max(1,int(current_page)-3)+7) 
        
    
    return render(request, "statistics/details.html", {'field_list':field_list,
                                                       'entry_list': p.page(current_page),
                                                       'pages': page_range,
                                                       'last_page':p.num_pages,
                                                       })

def heatmap(request):
    """ basic function to plot heatmaps for plate replicates\
        can expand to plot many different statistics    
    """
    ### This function is still in the testing phase
    ### because one plate seems like have more than 384 wells...
    if 'proj' in request.session: 
        exec ('from data.models import proj_'+request.session['proj_id']+' as data')
        ## Retrive data to be ploted
        plate_number = '2'        
        entry_list = data.objects.filter(plate = plate_number)
        
        replicate_dic = {}       
        for e in entry_list:
            if e.replicate not in replicate_dic.keys():
                well = []
                fp = []
                replicate_dic.update({e.replicate:[well,fp]})
                replicate_dic[e.replicate][0].append(e.well)
                replicate_dic[e.replicate][1].append(float(e.FP))
            else:
                replicate_dic[e.replicate][0].append(e.well)
                replicate_dic[e.replicate][1].append(float(e.FP))

        ## Plot Heat maps
        img_strings = ''
        for k in replicate_dic.keys():
            well_list = replicate_dic[k][0]
            fp_list = replicate_dic[k][1]            
            img_strings += stat.plot_plate_heatmap(well_list, fp_list,plate_number = (plate_number+k))     
        
        ## Plot Reproductivity   
        ## This plot might have bug if A and B doesn't have same well number
        ## This will be addressed in the future
        img_strings += stat.plot_linearfit(replicate_dic['A'][1],replicate_dic['B'][1], (plate_number+'A'),(plate_number+'B'))

        ## Plot Histogram
        img_strings += stat.plot_histogram((replicate_dic['A'][1]+replicate_dic['B'][1]))
        return HttpResponse(img_strings)        

    else:
        return render(request,"main/data_list.html",{}) ## return address need to be re-defined




#def details(request):
#
#    if 'proj' in request.session: 
#        exec ('from data.models import proj_'+request.session['proj_id']+' as data')
#        entry_list = data.objects.all()
#        field_list = list()
#        for i in data._meta.fields:
#            field_list.append(i.name)
#    
#        current_page = (request.GET.get('page'))
#            
#        p = Paginator(entry_list,30)    
#        
#        if not current_page:
#            current_page=1
#        
#        if int(current_page)+3 >= p.num_pages:
#            page_range = range(p.num_pages - 7, p.num_pages)
#        else:
#            page_range = range(max(1,int(current_page)-3),max(1,int(current_page)-3)+7) 
#            
#    
#        return render(request, "main/data_list.html",{'entry_list': p.page(current_page),
#                                                      'field_list': field_list,
#                                                      'pages': page_range,
#                                                      'last_page':p.num_pages
#                                                    })
#    else:
#        return render(request,"main/data_list.html",{})




#=============================================================================
## Testing views


import numpy as np
import matplotlib.pyplot as plt
import xml.etree.ElementTree as ET
from StringIO import StringIO
import json

def interactive_test(request):

    plt.rcParams['svg.embed_char_paths'] = 'none'
    
    # Apparently, this `register_namespace` method works only with
    # python 2.7 and up and is necessary to avoid garbling the XML name
    # space with ns0.
    ET.register_namespace("","http://www.w3.org/2000/svg")
    
    
    
    
    # --- Create histogram, legend and title ---
    plt.figure()
    r = np.random.randn(100)
    r1 = r + 1
    labels = ['Rabbits', 'Frogs']
    H = plt.hist([r,r1], label=labels)
    containers = H[-1]
    leg = plt.legend(frameon=False)
    plt.title("""From a web browser, click on the legend
    marker to toggle the corresponding histogram.""")
    
    
    # --- Add ids to the svg objects we'll modify
    
    hist_patches = {}
    for ic, c in enumerate(containers):
        hist_patches['hist_%d'%ic] = []
        for il, element in enumerate(c):
            element.set_gid('hist_%d_patch_%d'%(ic, il))
            hist_patches['hist_%d'%ic].append('hist_%d_patch_%d'%(ic,il))
    
    # Set ids for the legend patches
    for i, t in enumerate(leg.get_patches()):
        t.set_gid('leg_patch_%d'%i)
    
    # Set ids for the text patches
    for i, t in enumerate(leg.get_texts()):
        t.set_gid('leg_text_%d'%i)
    
    # Save SVG in a fake file object.
    f = StringIO()
    plt.savefig(f, format="svg")
    
    # Create XML tree from the SVG file.
    tree, xmlid = ET.XMLID(f.getvalue())
    
    
    # --- Add interactivity ---
    
    # Add attributes to the patch objects.
    for i, t in enumerate(leg.get_patches()):
        el = xmlid['leg_patch_%d'%i]
        el.set('cursor', 'pointer')
        el.set('onclick', "toggle_hist(this)")
    
    # Add attributes to the text objects.
    for i, t in enumerate(leg.get_texts()):
        el = xmlid['leg_text_%d'%i]
        el.set('cursor', 'pointer')
        el.set('onclick', "toggle_hist(this)")
    
    # Create script defining the function `toggle_hist`.
    # We create a global variable `container` that stores the patches id
    # belonging to each histogram. Then a function "toggle_element" sets the
    # visibility attribute of all patches of each histogram and the opacity
    # of the marker itself.
    
    script = """
    <script type="text/ecmascript">
    <![CDATA[
    var container = %s
    
    function toggle(oid, attribute, values) {
        /* Toggle the style attribute of an object between two values.
    
        Parameters
        ----------
        oid : str
          Object identifier.
        attribute : str
          Name of syle attribute.
        values : [on state, off state]
          The two values that are switched between.
        */
        var obj = document.getElementById(oid);
        var a = obj.style[attribute];
    
        a = (a == values[0] || a == "") ? values[1] : values[0];
        obj.style[attribute] = a;
        }
    
    function toggle_hist(obj) {
    
        var num = obj.id.slice(-1);
    
        toggle('leg_patch_' + num, 'opacity', [1, 0.3]);
        toggle('leg_text_' + num, 'opacity', [1, 0.5]);
    
        var names = container['hist_'+num]
    
        for (var i=0; i < names.length; i++) {
            toggle(names[i], 'opacity', [1,0])
        };
        }
    ]]>
    </script>
    """%json.dumps(hist_patches)
    
    # Add a transition effect
    css = tree.getchildren()[0][0]
    css.text = css.text + "g {-webkit-transition:opacity 0.4s ease-out;-moz-transition:opacity 0.4s ease-out;}"
    
    # Insert the script and save to file.
    tree.insert(0, ET.XML(script))
    fout = StringIO()
    ET.ElementTree(tree).write(fout)
    
    return StreamingHttpResponse(fout)
